{-# LANGUAGE DeriveGeneric     #-}
{-# LANGUAGE DeriveAnyClass    #-}
{-# LANGUAGE DataKinds         #-}
{-# LANGUAGE GADTs             #-}
{-# LANGUAGE TypeApplications  #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-- | Generated by Haskell protocol buffer compiler. DO NOT EDIT!
module Com.Digitalasset.Ledger.Api.V1.LedgerOffset where
import qualified Prelude as Hs
import qualified Proto3.Suite.Class as HsProtobuf
import qualified Proto3.Suite.DotProto as HsProtobuf
import qualified Proto3.Suite.JSONPB as HsJSONPB
import Proto3.Suite.JSONPB ((.=), (.:))
import qualified Proto3.Suite.Types as HsProtobuf
import qualified Proto3.Wire as HsProtobuf
import qualified Control.Applicative as Hs
import Control.Applicative ((<*>), (<|>), (<$>))
import qualified Control.DeepSeq as Hs
import qualified Control.Monad as Hs
import qualified Data.ByteString as Hs
import qualified Data.Coerce as Hs
import qualified Data.Int as Hs (Int16, Int32, Int64)
import qualified Data.List.NonEmpty as Hs (NonEmpty(..))
import qualified Data.Map as Hs (Map, mapKeysMonotonic)
import qualified Data.Proxy as Proxy
import qualified Data.String as Hs (fromString)
import qualified Data.Text.Lazy as Hs (Text)
import qualified Data.Vector as Hs (Vector)
import qualified Data.Word as Hs (Word16, Word32, Word64)
import qualified GHC.Enum as Hs
import qualified GHC.Generics as Hs
import qualified Unsafe.Coerce as Hs
 
data LedgerOffset = LedgerOffset{ledgerOffsetValue ::
                                 Hs.Maybe LedgerOffsetValue}
                  deriving (Hs.Show, Hs.Eq, Hs.Ord, Hs.Generic, Hs.NFData)
 
instance HsProtobuf.Named LedgerOffset where
        nameOf _ = (Hs.fromString "LedgerOffset")
 
instance HsProtobuf.HasDefault LedgerOffset
 
instance HsProtobuf.Message LedgerOffset where
        encodeMessage _ LedgerOffset{ledgerOffsetValue = ledgerOffsetValue}
          = (Hs.mconcat
               [case ledgerOffsetValue of
                    Hs.Nothing -> Hs.mempty
                    Hs.Just x
                      -> case x of
                             LedgerOffsetValueAbsolute y
                               -> (HsProtobuf.encodeMessageField (HsProtobuf.FieldNumber 1)
                                     (HsProtobuf.ForceEmit y))
                             LedgerOffsetValueBoundary y
                               -> (HsProtobuf.encodeMessageField (HsProtobuf.FieldNumber 2)
                                     (HsProtobuf.ForceEmit y))])
        decodeMessage _
          = (Hs.pure LedgerOffset) <*>
              (HsProtobuf.oneof Hs.Nothing
                 [((HsProtobuf.FieldNumber 1),
                   (Hs.pure (Hs.Just Hs.. LedgerOffsetValueAbsolute)) <*>
                     HsProtobuf.decodeMessageField),
                  ((HsProtobuf.FieldNumber 2),
                   (Hs.pure (Hs.Just Hs.. LedgerOffsetValueBoundary)) <*>
                     HsProtobuf.decodeMessageField)])
        dotProto _ = []
 
instance HsJSONPB.ToJSONPB LedgerOffset where
        toJSONPB (LedgerOffset f1_or_f2)
          = (HsJSONPB.object
               [(let encodeValue
                       = (case f1_or_f2 of
                              Hs.Just (LedgerOffsetValueAbsolute f1)
                                -> (HsJSONPB.pair "absolute" f1)
                              Hs.Just (LedgerOffsetValueBoundary f2)
                                -> (HsJSONPB.pair "boundary" f2)
                              Hs.Nothing -> Hs.mempty)
                   in
                   \ options ->
                     if HsJSONPB.optEmitNamedOneof options then
                       ("value" .= (HsJSONPB.objectOrNull [encodeValue] options)) options
                       else encodeValue options)])
        toEncodingPB (LedgerOffset f1_or_f2)
          = (HsJSONPB.pairs
               [(let encodeValue
                       = (case f1_or_f2 of
                              Hs.Just (LedgerOffsetValueAbsolute f1)
                                -> (HsJSONPB.pair "absolute" f1)
                              Hs.Just (LedgerOffsetValueBoundary f2)
                                -> (HsJSONPB.pair "boundary" f2)
                              Hs.Nothing -> Hs.mempty)
                   in
                   \ options ->
                     if HsJSONPB.optEmitNamedOneof options then
                       ("value" .= (HsJSONPB.pairsOrNull [encodeValue] options)) options
                       else encodeValue options)])
 
instance HsJSONPB.FromJSONPB LedgerOffset where
        parseJSONPB
          = (HsJSONPB.withObject "LedgerOffset"
               (\ obj ->
                  (Hs.pure LedgerOffset) <*>
                    (let parseValue parseObj
                           = Hs.msum
                               [Hs.Just Hs.. LedgerOffsetValueAbsolute <$>
                                  (HsJSONPB.parseField parseObj "absolute"),
                                Hs.Just Hs.. LedgerOffsetValueBoundary <$>
                                  (HsJSONPB.parseField parseObj "boundary"),
                                Hs.pure Hs.Nothing]
                       in
                       ((obj .: "value") Hs.>>= (HsJSONPB.withObject "value" parseValue))
                         <|> (parseValue obj))))
 
instance HsJSONPB.ToJSON LedgerOffset where
        toJSON = HsJSONPB.toAesonValue
        toEncoding = HsJSONPB.toAesonEncoding
 
instance HsJSONPB.FromJSON LedgerOffset where
        parseJSON = HsJSONPB.parseJSONPB
 
instance HsJSONPB.ToSchema LedgerOffset where
        declareNamedSchema _
          = do let declare_value = HsJSONPB.declareSchemaRef
               ledgerOffsetValue <- declare_value Proxy.Proxy
               let _ = Hs.pure LedgerOffset <*> HsJSONPB.asProxy declare_value
               Hs.return
                 (HsJSONPB.NamedSchema{HsJSONPB._namedSchemaName =
                                         Hs.Just "LedgerOffset",
                                       HsJSONPB._namedSchemaSchema =
                                         Hs.mempty{HsJSONPB._schemaParamSchema =
                                                     Hs.mempty{HsJSONPB._paramSchemaType =
                                                                 Hs.Just HsJSONPB.SwaggerObject},
                                                   HsJSONPB._schemaProperties =
                                                     HsJSONPB.insOrdFromList
                                                       [("value", ledgerOffsetValue)]}})
 
data LedgerOffset_LedgerBoundary = LedgerOffset_LedgerBoundaryLEDGER_BEGIN
                                 | LedgerOffset_LedgerBoundaryLEDGER_END
                                 deriving (Hs.Show, Hs.Eq, Hs.Generic, Hs.NFData)
 
instance HsProtobuf.Named LedgerOffset_LedgerBoundary where
        nameOf _ = (Hs.fromString "LedgerOffset_LedgerBoundary")
 
instance HsProtobuf.HasDefault LedgerOffset_LedgerBoundary
 
instance Hs.Bounded LedgerOffset_LedgerBoundary where
        minBound = LedgerOffset_LedgerBoundaryLEDGER_BEGIN
        maxBound = LedgerOffset_LedgerBoundaryLEDGER_END
 
instance Hs.Ord LedgerOffset_LedgerBoundary where
        compare x y
          = Hs.compare (HsProtobuf.fromProtoEnum x)
              (HsProtobuf.fromProtoEnum y)
 
instance HsProtobuf.ProtoEnum LedgerOffset_LedgerBoundary where
        toProtoEnumMay 0 = Hs.Just LedgerOffset_LedgerBoundaryLEDGER_BEGIN
        toProtoEnumMay 1 = Hs.Just LedgerOffset_LedgerBoundaryLEDGER_END
        toProtoEnumMay _ = Hs.Nothing
        fromProtoEnum (LedgerOffset_LedgerBoundaryLEDGER_BEGIN) = 0
        fromProtoEnum (LedgerOffset_LedgerBoundaryLEDGER_END) = 1
 
instance HsJSONPB.ToJSONPB LedgerOffset_LedgerBoundary where
        toJSONPB x _ = HsJSONPB.enumFieldString x
        toEncodingPB x _ = HsJSONPB.enumFieldEncoding x
 
instance HsJSONPB.FromJSONPB LedgerOffset_LedgerBoundary where
        parseJSONPB (HsJSONPB.String "LEDGER_BEGIN")
          = Hs.pure LedgerOffset_LedgerBoundaryLEDGER_BEGIN
        parseJSONPB (HsJSONPB.String "LEDGER_END")
          = Hs.pure LedgerOffset_LedgerBoundaryLEDGER_END
        parseJSONPB v
          = (HsJSONPB.typeMismatch "LedgerOffset_LedgerBoundary" v)
 
instance HsJSONPB.ToJSON LedgerOffset_LedgerBoundary where
        toJSON = HsJSONPB.toAesonValue
        toEncoding = HsJSONPB.toAesonEncoding
 
instance HsJSONPB.FromJSON LedgerOffset_LedgerBoundary where
        parseJSON = HsJSONPB.parseJSONPB
 
instance HsProtobuf.Finite LedgerOffset_LedgerBoundary
 
data LedgerOffsetValue = LedgerOffsetValueAbsolute Hs.Text
                       | LedgerOffsetValueBoundary (HsProtobuf.Enumerated
                                                      Com.Digitalasset.Ledger.Api.V1.LedgerOffset.LedgerOffset_LedgerBoundary)
                       deriving (Hs.Show, Hs.Eq, Hs.Ord, Hs.Generic, Hs.NFData)
 
instance HsProtobuf.Named LedgerOffsetValue where
        nameOf _ = (Hs.fromString "LedgerOffsetValue")
 
instance HsJSONPB.ToSchema LedgerOffsetValue where
        declareNamedSchema _
          = do let declare_absolute = HsJSONPB.declareSchemaRef
               ledgerOffsetValueAbsolute <- declare_absolute Proxy.Proxy
               let _ = Hs.pure LedgerOffsetValueAbsolute <*>
                         HsJSONPB.asProxy declare_absolute
               let declare_boundary = HsJSONPB.declareSchemaRef
               ledgerOffsetValueBoundary <- declare_boundary Proxy.Proxy
               let _ = Hs.pure LedgerOffsetValueBoundary <*>
                         HsJSONPB.asProxy declare_boundary
               Hs.return
                 (HsJSONPB.NamedSchema{HsJSONPB._namedSchemaName =
                                         Hs.Just "LedgerOffsetValue",
                                       HsJSONPB._namedSchemaSchema =
                                         Hs.mempty{HsJSONPB._schemaParamSchema =
                                                     Hs.mempty{HsJSONPB._paramSchemaType =
                                                                 Hs.Just HsJSONPB.SwaggerObject},
                                                   HsJSONPB._schemaProperties =
                                                     HsJSONPB.insOrdFromList
                                                       [("absolute", ledgerOffsetValueAbsolute),
                                                        ("boundary", ledgerOffsetValueBoundary)],
                                                   HsJSONPB._schemaMinProperties = Hs.Just 1,
                                                   HsJSONPB._schemaMaxProperties = Hs.Just 1}})