{-# LANGUAGE DeriveGeneric     #-}
{-# LANGUAGE DeriveAnyClass    #-}
{-# LANGUAGE DataKinds         #-}
{-# LANGUAGE GADTs             #-}
{-# LANGUAGE TypeApplications  #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-- | Generated by Haskell protocol buffer compiler. DO NOT EDIT!
module Com.Digitalasset.Ledger.Api.V1.TransactionFilter where
import qualified Prelude as Hs
import qualified Proto3.Suite.Class as HsProtobuf
import qualified Proto3.Suite.DotProto as HsProtobuf
import qualified Proto3.Suite.JSONPB as HsJSONPB
import Proto3.Suite.JSONPB ((.=), (.:))
import qualified Proto3.Suite.Types as HsProtobuf
import qualified Proto3.Wire as HsProtobuf
import qualified Control.Applicative as Hs
import Control.Applicative ((<*>), (<|>), (<$>))
import qualified Control.DeepSeq as Hs
import qualified Control.Monad as Hs
import qualified Data.ByteString as Hs
import qualified Data.Coerce as Hs
import qualified Data.Int as Hs (Int16, Int32, Int64)
import qualified Data.List.NonEmpty as Hs (NonEmpty(..))
import qualified Data.Map as Hs (Map, mapKeysMonotonic)
import qualified Data.Proxy as Proxy
import qualified Data.String as Hs (fromString)
import qualified Data.Text.Lazy as Hs (Text)
import qualified Data.Vector as Hs (Vector)
import qualified Data.Word as Hs (Word16, Word32, Word64)
import qualified GHC.Enum as Hs
import qualified GHC.Generics as Hs
import qualified Unsafe.Coerce as Hs
import qualified Com.Digitalasset.Ledger.Api.V1.Value
 
data TransactionFilter = TransactionFilter{transactionFilterFiltersByParty
                                           ::
                                           Hs.Map Hs.Text
                                             (Hs.Maybe
                                                Com.Digitalasset.Ledger.Api.V1.TransactionFilter.Filters)}
                       deriving (Hs.Show, Hs.Eq, Hs.Ord, Hs.Generic, Hs.NFData)
 
instance HsProtobuf.Named TransactionFilter where
        nameOf _ = (Hs.fromString "TransactionFilter")
 
instance HsProtobuf.HasDefault TransactionFilter
 
instance HsProtobuf.Message TransactionFilter where
        encodeMessage _
          TransactionFilter{transactionFilterFiltersByParty =
                              transactionFilterFiltersByParty}
          = (Hs.mconcat
               [(HsProtobuf.encodeMessageField (HsProtobuf.FieldNumber 1)
                   (Hs.unsafeCoerce
                      @(Hs.Map Hs.Text (Hs.Maybe Com.Digitalasset.Ledger.Api.V1.TransactionFilter.Filters))
                      @(Hs.Map Hs.Text (HsProtobuf.Nested Com.Digitalasset.Ledger.Api.V1.TransactionFilter.Filters))
                      transactionFilterFiltersByParty))])
        decodeMessage _
          = (Hs.pure TransactionFilter) <*>
              (Hs.unsafeCoerce
                 @(_ (Hs.Map Hs.Text (HsProtobuf.Nested Com.Digitalasset.Ledger.Api.V1.TransactionFilter.Filters)))
                 @(_ (Hs.Map Hs.Text (Hs.Maybe Com.Digitalasset.Ledger.Api.V1.TransactionFilter.Filters)))
                 (HsProtobuf.at HsProtobuf.decodeMessageField
                    (HsProtobuf.FieldNumber 1)))
        dotProto _
          = [(HsProtobuf.DotProtoField (HsProtobuf.FieldNumber 1)
                (HsProtobuf.Map HsProtobuf.String
                   (HsProtobuf.Named (HsProtobuf.Single "Filters")))
                (HsProtobuf.Single "filters_by_party")
                []
                "")]
 
instance HsJSONPB.ToJSONPB TransactionFilter where
        toJSONPB (TransactionFilter f1)
          = (HsJSONPB.object ["filters_by_party" .= f1])
        toEncodingPB (TransactionFilter f1)
          = (HsJSONPB.pairs ["filters_by_party" .= f1])
 
instance HsJSONPB.FromJSONPB TransactionFilter where
        parseJSONPB
          = (HsJSONPB.withObject "TransactionFilter"
               (\ obj ->
                  (Hs.pure TransactionFilter) <*> obj .: "filters_by_party"))
 
instance HsJSONPB.ToJSON TransactionFilter where
        toJSON = HsJSONPB.toAesonValue
        toEncoding = HsJSONPB.toAesonEncoding
 
instance HsJSONPB.FromJSON TransactionFilter where
        parseJSON = HsJSONPB.parseJSONPB
 
instance HsJSONPB.ToSchema TransactionFilter where
        declareNamedSchema _
          = do let declare_filters_by_party = HsJSONPB.declareSchemaRef
               transactionFilterFiltersByParty <- declare_filters_by_party
                                                    Proxy.Proxy
               let _ = Hs.pure TransactionFilter <*>
                         HsJSONPB.asProxy declare_filters_by_party
               Hs.return
                 (HsJSONPB.NamedSchema{HsJSONPB._namedSchemaName =
                                         Hs.Just "TransactionFilter",
                                       HsJSONPB._namedSchemaSchema =
                                         Hs.mempty{HsJSONPB._schemaParamSchema =
                                                     Hs.mempty{HsJSONPB._paramSchemaType =
                                                                 Hs.Just HsJSONPB.SwaggerObject},
                                                   HsJSONPB._schemaProperties =
                                                     HsJSONPB.insOrdFromList
                                                       [("filters_by_party",
                                                         transactionFilterFiltersByParty)]}})
 
data Filters = Filters{filtersInclusive ::
                       Hs.Maybe
                         Com.Digitalasset.Ledger.Api.V1.TransactionFilter.InclusiveFilters}
             deriving (Hs.Show, Hs.Eq, Hs.Ord, Hs.Generic, Hs.NFData)
 
instance HsProtobuf.Named Filters where
        nameOf _ = (Hs.fromString "Filters")
 
instance HsProtobuf.HasDefault Filters
 
instance HsProtobuf.Message Filters where
        encodeMessage _ Filters{filtersInclusive = filtersInclusive}
          = (Hs.mconcat
               [(HsProtobuf.encodeMessageField (HsProtobuf.FieldNumber 1)
                   (Hs.coerce
                      @(Hs.Maybe Com.Digitalasset.Ledger.Api.V1.TransactionFilter.InclusiveFilters)
                      @(HsProtobuf.Nested Com.Digitalasset.Ledger.Api.V1.TransactionFilter.InclusiveFilters)
                      filtersInclusive))])
        decodeMessage _
          = (Hs.pure Filters) <*>
              (Hs.coerce
                 @(_ (HsProtobuf.Nested Com.Digitalasset.Ledger.Api.V1.TransactionFilter.InclusiveFilters))
                 @(_ (Hs.Maybe Com.Digitalasset.Ledger.Api.V1.TransactionFilter.InclusiveFilters))
                 (HsProtobuf.at HsProtobuf.decodeMessageField
                    (HsProtobuf.FieldNumber 1)))
        dotProto _
          = [(HsProtobuf.DotProtoField (HsProtobuf.FieldNumber 1)
                (HsProtobuf.Prim
                   (HsProtobuf.Named (HsProtobuf.Single "InclusiveFilters")))
                (HsProtobuf.Single "inclusive")
                []
                "")]
 
instance HsJSONPB.ToJSONPB Filters where
        toJSONPB (Filters f1) = (HsJSONPB.object ["inclusive" .= f1])
        toEncodingPB (Filters f1) = (HsJSONPB.pairs ["inclusive" .= f1])
 
instance HsJSONPB.FromJSONPB Filters where
        parseJSONPB
          = (HsJSONPB.withObject "Filters"
               (\ obj -> (Hs.pure Filters) <*> obj .: "inclusive"))
 
instance HsJSONPB.ToJSON Filters where
        toJSON = HsJSONPB.toAesonValue
        toEncoding = HsJSONPB.toAesonEncoding
 
instance HsJSONPB.FromJSON Filters where
        parseJSON = HsJSONPB.parseJSONPB
 
instance HsJSONPB.ToSchema Filters where
        declareNamedSchema _
          = do let declare_inclusive = HsJSONPB.declareSchemaRef
               filtersInclusive <- declare_inclusive Proxy.Proxy
               let _ = Hs.pure Filters <*> HsJSONPB.asProxy declare_inclusive
               Hs.return
                 (HsJSONPB.NamedSchema{HsJSONPB._namedSchemaName =
                                         Hs.Just "Filters",
                                       HsJSONPB._namedSchemaSchema =
                                         Hs.mempty{HsJSONPB._schemaParamSchema =
                                                     Hs.mempty{HsJSONPB._paramSchemaType =
                                                                 Hs.Just HsJSONPB.SwaggerObject},
                                                   HsJSONPB._schemaProperties =
                                                     HsJSONPB.insOrdFromList
                                                       [("inclusive", filtersInclusive)]}})
 
data InclusiveFilters = InclusiveFilters{inclusiveFiltersTemplateIds
                                         ::
                                         Hs.Vector Com.Digitalasset.Ledger.Api.V1.Value.Identifier}
                      deriving (Hs.Show, Hs.Eq, Hs.Ord, Hs.Generic, Hs.NFData)
 
instance HsProtobuf.Named InclusiveFilters where
        nameOf _ = (Hs.fromString "InclusiveFilters")
 
instance HsProtobuf.HasDefault InclusiveFilters
 
instance HsProtobuf.Message InclusiveFilters where
        encodeMessage _
          InclusiveFilters{inclusiveFiltersTemplateIds =
                             inclusiveFiltersTemplateIds}
          = (Hs.mconcat
               [(HsProtobuf.encodeMessageField (HsProtobuf.FieldNumber 1)
                   (Hs.coerce
                      @(Hs.Vector Com.Digitalasset.Ledger.Api.V1.Value.Identifier)
                      @(HsProtobuf.NestedVec Com.Digitalasset.Ledger.Api.V1.Value.Identifier)
                      inclusiveFiltersTemplateIds))])
        decodeMessage _
          = (Hs.pure InclusiveFilters) <*>
              (Hs.coerce
                 @(_ (HsProtobuf.NestedVec Com.Digitalasset.Ledger.Api.V1.Value.Identifier))
                 @(_ (Hs.Vector Com.Digitalasset.Ledger.Api.V1.Value.Identifier))
                 (HsProtobuf.at HsProtobuf.decodeMessageField
                    (HsProtobuf.FieldNumber 1)))
        dotProto _
          = [(HsProtobuf.DotProtoField (HsProtobuf.FieldNumber 1)
                (HsProtobuf.Repeated
                   (HsProtobuf.Named (HsProtobuf.Single "Identifier")))
                (HsProtobuf.Single "template_ids")
                []
                "")]
 
instance HsJSONPB.ToJSONPB InclusiveFilters where
        toJSONPB (InclusiveFilters f1)
          = (HsJSONPB.object ["template_ids" .= f1])
        toEncodingPB (InclusiveFilters f1)
          = (HsJSONPB.pairs ["template_ids" .= f1])
 
instance HsJSONPB.FromJSONPB InclusiveFilters where
        parseJSONPB
          = (HsJSONPB.withObject "InclusiveFilters"
               (\ obj -> (Hs.pure InclusiveFilters) <*> obj .: "template_ids"))
 
instance HsJSONPB.ToJSON InclusiveFilters where
        toJSON = HsJSONPB.toAesonValue
        toEncoding = HsJSONPB.toAesonEncoding
 
instance HsJSONPB.FromJSON InclusiveFilters where
        parseJSON = HsJSONPB.parseJSONPB
 
instance HsJSONPB.ToSchema InclusiveFilters where
        declareNamedSchema _
          = do let declare_template_ids = HsJSONPB.declareSchemaRef
               inclusiveFiltersTemplateIds <- declare_template_ids Proxy.Proxy
               let _ = Hs.pure InclusiveFilters <*>
                         HsJSONPB.asProxy declare_template_ids
               Hs.return
                 (HsJSONPB.NamedSchema{HsJSONPB._namedSchemaName =
                                         Hs.Just "InclusiveFilters",
                                       HsJSONPB._namedSchemaSchema =
                                         Hs.mempty{HsJSONPB._schemaParamSchema =
                                                     Hs.mempty{HsJSONPB._paramSchemaType =
                                                                 Hs.Just HsJSONPB.SwaggerObject},
                                                   HsJSONPB._schemaProperties =
                                                     HsJSONPB.insOrdFromList
                                                       [("template_ids",
                                                         inclusiveFiltersTemplateIds)]}})